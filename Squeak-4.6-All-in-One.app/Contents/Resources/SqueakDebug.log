MessageNotUnderstood: BlankCellTestCase>>leansLeft:12 August 2015 11:41:26.799 amVM: Win32 - SmalltalkImage: Squeak4.6 [latest update: #15102]SecurityManager state:Restricted: falseFileAccess: trueSocketAccess: trueWorking Dir C:\prj\monoRailSqueak\Squeak-4.6-All-in-One.app\Contents\ResourcesTrusted Dir C:\prj\monoRailSqueak\Squeak-4.6-All-in-One.app\Contents\Resources\SeongsikUntrusted Dir C:\Users\Seongsik\Documents\My SqueakBlankCellTestCase(Object)>>doesNotUnderstand: #leansLeft:	Receiver: a BlankCellTestCase	Arguments and temporary variables: 		aMessage: 	leansLeft: true		exception: 	MessageNotUnderstood: BlankCellTestCase>>leansLeft:		resumeValue: 	nil	Receiver's instance variables: 		testSelector: 	nil		timeout: 	nilBlankCellTestCase>>initialize	Receiver: a BlankCellTestCase	Arguments and temporary variables: 	Receiver's instance variables: 		testSelector: 	nil		timeout: 	nilBlankCellTestCase class(Behavior)>>new	Receiver: BlankCellTestCase	Arguments and temporary variables: 	Receiver's instance variables: 		superclass: 	TestCase		methodDict: 	a MethodDictionary(#initialize->(BlankCellTestCase>>#initialize "a ...etc...		format: 	134		instanceVariables: 	nil		organization: 	('initialize-release' initialize)('tests' testCellExitSides test...etc...		subclasses: 	nil		name: 	#BlankCellTestCase		classPool: 	nil		sharedPools: 	nil		environment: 	Smalltalk		category: 	#'Laser-Game-Tests'		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...BlankCellTestCase class(TestCase class)>>selector:	Receiver: BlankCellTestCase	Arguments and temporary variables: 		aSymbol: 	#testCellExitSides	Receiver's instance variables: 		superclass: 	TestCase		methodDict: 	a MethodDictionary(#initialize->(BlankCellTestCase>>#initialize "a ...etc...		format: 	134		instanceVariables: 	nil		organization: 	('initialize-release' initialize)('tests' testCellExitSides test...etc...		subclasses: 	nil		name: 	#BlankCellTestCase		classPool: 	nil		sharedPools: 	nil		environment: 	Smalltalk		category: 	#'Laser-Game-Tests'		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...[] in BlankCellTestCase class(TestCase class)>>addToSuite:fromMethods:	Receiver: BlankCellTestCase	Arguments and temporary variables: 		suite: 	#testCellExitSides		testMethods: 	a TestSuite		selector: 	a TestSuite	Receiver's instance variables: 		superclass: 	TestCase		methodDict: 	a MethodDictionary(#initialize->(BlankCellTestCase>>#initialize "a ...etc...		format: 	134		instanceVariables: 	nil		organization: 	('initialize-release' initialize)('tests' testCellExitSides test...etc...		subclasses: 	nil		name: 	#BlankCellTestCase		classPool: 	nil		sharedPools: 	nil		environment: 	Smalltalk		category: 	#'Laser-Game-Tests'		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...Array(SequenceableCollection)>>do:	Receiver: #(#testCellExitSides #testCellLaserActivity #testCellOnState #testCellSegmentsState)	Arguments and temporary variables: 		aBlock: 	[closure] in BlankCellTestCase class(TestCase class)>>addToSuite:fromMe...etc...		index: 	1		indexLimiT: 	4	Receiver's instance variables: #(#testCellExitSides #testCellLaserActivity #testCellOnState #testCellSegmentsState)BlankCellTestCase class(TestCase class)>>addToSuite:fromMethods:	Receiver: BlankCellTestCase	Arguments and temporary variables: 		suite: 	a TestSuite		testMethods: 	#(#testCellExitSides #testCellLaserActivity #testCellOnState #test...etc...	Receiver's instance variables: 		superclass: 	TestCase		methodDict: 	a MethodDictionary(#initialize->(BlankCellTestCase>>#initialize "a ...etc...		format: 	134		instanceVariables: 	nil		organization: 	('initialize-release' initialize)('tests' testCellExitSides test...etc...		subclasses: 	nil		name: 	#BlankCellTestCase		classPool: 	nil		sharedPools: 	nil		environment: 	Smalltalk		category: 	#'Laser-Game-Tests'		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...BlankCellTestCase class(TestCase class)>>addToSuiteFromSelectors:	Receiver: BlankCellTestCase	Arguments and temporary variables: 		suite: 	a TestSuite	Receiver's instance variables: 		superclass: 	TestCase		methodDict: 	a MethodDictionary(#initialize->(BlankCellTestCase>>#initialize "a ...etc...		format: 	134		instanceVariables: 	nil		organization: 	('initialize-release' initialize)('tests' testCellExitSides test...etc...		subclasses: 	nil		name: 	#BlankCellTestCase		classPool: 	nil		sharedPools: 	nil		environment: 	Smalltalk		category: 	#'Laser-Game-Tests'		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...[] in [] in TestRunner>>suiteAll	Receiver: a TestRunner	Arguments and temporary variables: 		suite: 	BlankCellTestCase		each: 	a TestSuite	Receiver's instance variables: 		categories: 	#(#'KernelTests-Chronology' #'KernelTests-Classes' #'KernelTests-Me...etc...		categoriesSelected: 	a Set(#'Laser-Game-Tests')		classes: 	{BlankCellTestCase}		classIndex: 	0		classesSelected: 	a Set(BlankCellTestCase)		failedList: 	#()		failedSelected: 	nil		errorList: 	#()		errorSelected: 	nil		lastUpdate: 	3616832486		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...		previousRun: 	nil		categoryPattern: 	nil		classPattern: 	nilSet>>do:	Receiver: a Set(BlankCellTestCase)	Arguments and temporary variables: 		aBlock: 	[closure] in [] in TestRunner>>suiteAll		element: 	BlankCellTestCase		index: 	2		indexLimiT: 	5	Receiver's instance variables: 		tally: 	1		array: 	{nil . BlankCellTestCase . nil . nil . nil}[] in TestRunner>>suiteAll	Receiver: a TestRunner	Arguments and temporary variables: 		suite: 	a TestSuite	Receiver's instance variables: 		categories: 	#(#'KernelTests-Chronology' #'KernelTests-Classes' #'KernelTests-Me...etc...		categoriesSelected: 	a Set(#'Laser-Game-Tests')		classes: 	{BlankCellTestCase}		classIndex: 	0		classesSelected: 	a Set(BlankCellTestCase)		failedList: 	#()		failedSelected: 	nil		errorList: 	#()		errorSelected: 	nil		lastUpdate: 	3616832486		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...		previousRun: 	nil		categoryPattern: 	nil		classPattern: 	nilTestSuite(Object)>>in:	Receiver: a TestSuite	Arguments and temporary variables: 		aBlock: 	[closure] in TestRunner>>suiteAll	Receiver's instance variables: 		tests: 	nil		resources: 	nil		name: 	nilTestRunner>>suiteAll	Receiver: a TestRunner	Arguments and temporary variables: 	Receiver's instance variables: 		categories: 	#(#'KernelTests-Chronology' #'KernelTests-Classes' #'KernelTests-Me...etc...		categoriesSelected: 	a Set(#'Laser-Game-Tests')		classes: 	{BlankCellTestCase}		classIndex: 	0		classesSelected: 	a Set(BlankCellTestCase)		failedList: 	#()		failedSelected: 	nil		errorList: 	#()		errorSelected: 	nil		lastUpdate: 	3616832486		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...		previousRun: 	nil		categoryPattern: 	nil		classPattern: 	nilTestRunner>>runAll	Receiver: a TestRunner	Arguments and temporary variables: 	Receiver's instance variables: 		categories: 	#(#'KernelTests-Chronology' #'KernelTests-Classes' #'KernelTests-Me...etc...		categoriesSelected: 	a Set(#'Laser-Game-Tests')		classes: 	{BlankCellTestCase}		classIndex: 	0		classesSelected: 	a Set(BlankCellTestCase)		failedList: 	#()		failedSelected: 	nil		errorList: 	#()		errorSelected: 	nil		lastUpdate: 	3616832486		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...		previousRun: 	nil		categoryPattern: 	nil		classPattern: 	nilPluggableButtonMorphPlus(PluggableButtonMorph)>>performAction	Receiver: a PluggableButtonMorphPlus(3175)	Arguments and temporary variables: 	Receiver's instance variables: 		bounds: 	21@961 corner: 145@987		owner: 	a PluggablePanelMorph(2825)		submorphs: 	#()		fullBounds: 	21@961 corner: 145@987		color: 	Color white		extension: 	a MorphExtension (3245) [other:  (minHeight -> 2) (clipSubmorphs -> ...etc...		borderWidth: 	1		borderColor: 	Color gray		model: 	a TestRunner		label: 	'Run Selected'		font: 	nil		getStateSelector: 	nil		actionSelector: 	#runAll		getLabelSelector: 	nil		getMenuSelector: 	nil		shortcutCharacter: 	nil		askBeforeChanging: 	false		triggerOnMouseDown: 	false		offColor: 	Color white		onColor: 	Color veryLightGray		feedbackColor: 	Color red		showSelectionFeedback: 	false		allButtons: 	{a PluggableButtonMorphPlus(3175) . a PluggableButtonMorphPlus(2165...etc...		arguments: 	nil		argumentsProvider: 	nil		argumentsSelector: 	nil		style: 	nil		enabled: 	true		action: 	nil		getColorSelector: 	nil		getEnabledSelector: 	#hasRunnable		updateMap: 	nilPluggableButtonMorphPlus>>performAction	Receiver: a PluggableButtonMorphPlus(3175)	Arguments and temporary variables: 	Receiver's instance variables: 		bounds: 	21@961 corner: 145@987		owner: 	a PluggablePanelMorph(2825)		submorphs: 	#()		fullBounds: 	21@961 corner: 145@987		color: 	Color white		extension: 	a MorphExtension (3245) [other:  (minHeight -> 2) (clipSubmorphs -> ...etc...		borderWidth: 	1		borderColor: 	Color gray		model: 	a TestRunner		label: 	'Run Selected'		font: 	nil		getStateSelector: 	nil		actionSelector: 	#runAll		getLabelSelector: 	nil		getMenuSelector: 	nil		shortcutCharacter: 	nil		askBeforeChanging: 	false		triggerOnMouseDown: 	false		offColor: 	Color white		onColor: 	Color veryLightGray		feedbackColor: 	Color red		showSelectionFeedback: 	false		allButtons: 	{a PluggableButtonMorphPlus(3175) . a PluggableButtonMorphPlus(2165...etc...		arguments: 	nil		argumentsProvider: 	nil		argumentsSelector: 	nil		style: 	nil		enabled: 	true		action: 	nil		getColorSelector: 	nil		getEnabledSelector: 	#hasRunnable		updateMap: 	nil[] in PluggableButtonMorphPlus(PluggableButtonMorph)>>mouseUp:	Receiver: a PluggableButtonMorphPlus(3175)	Arguments and temporary variables: 		evt: 	a PluggableButtonMorphPlus(3175)		m: 	[98@979 mouseUp 4903703]	Receiver's instance variables: 		bounds: 	21@961 corner: 145@987		owner: 	a PluggablePanelMorph(2825)		submorphs: 	#()		fullBounds: 	21@961 corner: 145@987		color: 	Color white		extension: 	a MorphExtension (3245) [other:  (minHeight -> 2) (clipSubmorphs -> ...etc...		borderWidth: 	1		borderColor: 	Color gray		model: 	a TestRunner		label: 	'Run Selected'		font: 	nil		getStateSelector: 	nil		actionSelector: 	#runAll		getLabelSelector: 	nil		getMenuSelector: 	nil		shortcutCharacter: 	nil		askBeforeChanging: 	false		triggerOnMouseDown: 	false		offColor: 	Color white		onColor: 	Color veryLightGray		feedbackColor: 	Color red		showSelectionFeedback: 	false		allButtons: 	{a PluggableButtonMorphPlus(3175) . a PluggableButtonMorphPlus(2165...etc...		arguments: 	nil		argumentsProvider: 	nil		argumentsSelector: 	nil		style: 	nil		enabled: 	true		action: 	nil		getColorSelector: 	nil		getEnabledSelector: 	#hasRunnable		updateMap: 	nilArray(SequenceableCollection)>>do:	Receiver: {a PluggableButtonMorphPlus(3175) . a PluggableButtonMorphPlus(2165) . a PluggableButtonMo...etc...	Arguments and temporary variables: 		aBlock: 	[closure] in PluggableButtonMorphPlus(PluggableButtonMorph)>>mouseUp:		index: 	1		indexLimiT: 	5	Receiver's instance variables: {a PluggableButtonMorphPlus(3175) . a PluggableButtonMorphPlus(2165) . a PluggableButtonMo...etc...PluggableButtonMorphPlus(PluggableButtonMorph)>>mouseUp:	Receiver: a PluggableButtonMorphPlus(3175)	Arguments and temporary variables: 		evt: 	[98@979 mouseUp 4903703]	Receiver's instance variables: 		bounds: 	21@961 corner: 145@987		owner: 	a PluggablePanelMorph(2825)		submorphs: 	#()		fullBounds: 	21@961 corner: 145@987		color: 	Color white		extension: 	a MorphExtension (3245) [other:  (minHeight -> 2) (clipSubmorphs -> ...etc...		borderWidth: 	1		borderColor: 	Color gray		model: 	a TestRunner		label: 	'Run Selected'		font: 	nil		getStateSelector: 	nil		actionSelector: 	#runAll		getLabelSelector: 	nil		getMenuSelector: 	nil		shortcutCharacter: 	nil		askBeforeChanging: 	false		triggerOnMouseDown: 	false		offColor: 	Color white		onColor: 	Color veryLightGray		feedbackColor: 	Color red		showSelectionFeedback: 	false		allButtons: 	{a PluggableButtonMorphPlus(3175) . a PluggableButtonMorphPlus(2165...etc...		arguments: 	nil		argumentsProvider: 	nil		argumentsSelector: 	nil		style: 	nil		enabled: 	true		action: 	nil		getColorSelector: 	nil		getEnabledSelector: 	#hasRunnable		updateMap: 	nil--- The full stack ---BlankCellTestCase(Object)>>doesNotUnderstand: #leansLeft:BlankCellTestCase>>initializeBlankCellTestCase class(Behavior)>>newBlankCellTestCase class(TestCase class)>>selector:[] in BlankCellTestCase class(TestCase class)>>addToSuite:fromMethods:Array(SequenceableCollection)>>do:BlankCellTestCase class(TestCase class)>>addToSuite:fromMethods:BlankCellTestCase class(TestCase class)>>addToSuiteFromSelectors:[] in [] in TestRunner>>suiteAllSet>>do:[] in TestRunner>>suiteAllTestSuite(Object)>>in:TestRunner>>suiteAllTestRunner>>runAllPluggableButtonMorphPlus(PluggableButtonMorph)>>performActionPluggableButtonMorphPlus>>performAction[] in PluggableButtonMorphPlus(PluggableButtonMorph)>>mouseUp:Array(SequenceableCollection)>>do:PluggableButtonMorphPlus(PluggableButtonMorph)>>mouseUp: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -PluggableButtonMorphPlus>>mouseUp:PluggableButtonMorphPlus(Morph)>>handleMouseUp:MouseButtonEvent>>sentTo:PluggableButtonMorphPlus(Morph)>>handleEvent:PluggableButtonMorphPlus(Morph)>>handleFocusEvent:[] in HandMorph>>sendFocusEvent:to:clear:BlockClosure>>on:do:PasteUpMorph>>becomeActiveDuring:HandMorph>>sendFocusEvent:to:clear:HandMorph>>sendEvent:focus:clear:HandMorph>>sendMouseEvent:HandMorph>>handleEvent:HandMorph>>processEvents[] in WorldState>>doOneCycleNowFor:Array(SequenceableCollection)>>do:WorldState>>handsDo:WorldState>>doOneCycleNowFor:WorldState>>doOneCycleFor:PasteUpMorph>>doOneCycle[] in MorphicProject>>spawnNewProcess[] in BlockClosure>>newProcess